<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Fundamentals Learning Notes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            padding: 40px;
        }
        
        h2 {
            color: #6366f1;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #6366f1;
            font-size: 1.8rem;
        }
        
        h2:first-child {
            margin-top: 0;
        }
        
        h3 {
            color: #8b5cf6;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        h4 {
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e91e63;
            font-size: 0.95em;
        }
        
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #6366f1;
        }
        
        pre code {
            background: none;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .success {
            background: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .error {
            background: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .info {
            background: #d1ecf1;
            padding: 15px;
            border-left: 4px solid #17a2b8;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        th {
            background: #6366f1;
            color: white;
        }
        
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .toc h3 {
            margin-top: 0;
            color: #6366f1;
        }
        
        .toc ul {
            list-style: none;
            margin-left: 0;
        }
        
        .toc a {
            color: #6366f1;
            text-decoration: none;
            transition: all 0.3s;
        }
        
        .toc a:hover {
            color: #8b5cf6;
            text-decoration: underline;
        }
        
        .flow-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: monospace;
            line-height: 2;
        }
        
        footer {
            background: #2d3748;
            color: white;
            padding: 20px;
            text-align: center;
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🚀 Complete React Fundamentals</h1>
            <p>From Scratch to Production - Learning Notes</p>
        </header>
        
        <div class="content">
            <!-- Table of Contents -->
            <div class="toc">
                <h3>📚 Table of Contents</h3>
                <ul>
                    <li><a href="#why-react">1. Why React Exists</a></li>
                    <li><a href="#rerender">2. Core Concept: React Re-renders</a></li>
                    <li><a href="#state-props">3. State vs Props</a></li>
                    <li><a href="#immutability">4. Why Props are Immutable</a></li>
                    <li><a href="#usestate">5. useState - Managing Component Memory</a></li>
                    <li><a href="#why-usestate">6. Why We Need useState</a></li>
                    <li><a href="#useeffect">7. useEffect - Handling Side Effects</a></li>
                    <li><a href="#dependency-array">8. useEffect Dependency Array</a></li>
                    <li><a href="#login-example">9. Real Example from Login Component</a></li>
                    <li><a href="#event-handling">10. Event Handling in React</a></li>
                    <li><a href="#controlled">11. Controlled vs Uncontrolled Components</a></li>
                    <li><a href="#local-state">12. Why Local State in Login Component</a></li>
                    <li><a href="#render-cycle">13. React Render Cycle</a></li>
                    <li><a href="#usestate-patterns">14. Common useState Patterns</a></li>
                    <li><a href="#typescript">15. TypeScript Types in React</a></li>
                    <li><a href="#mental-model">16. Memory Aid: React Mental Model</a></li>
                    <li><a href="#complete-flow">17. Login Component - Complete Flow</a></li>
                    <li><a href="#routing">18. React Router - Navigation System</a></li>
                    <li><a href="#protected-routes">19. Protected Routes - Authentication Guards</a></li>
                    <li><a href="#route-structure">20. Route Structure Best Practices</a></li>
                    <li><a href="#navigate-outlet">21. Navigate & Outlet Components</a></li>
                    <li><a href="#navigation-methods">22. Navigation Methods</a></li>
                    <li><a href="#role-based">23. Role-Based Protection (Advanced)</a></li>
                    <li><a href="#routing-flow">24. Complete Routing Flow</a></li>
                    <li><a href="#sync-async">25. Synchronous vs Asynchronous Programming</a></li>
                    <li><a href="#why-redux-async">26. Why Redux Needs Async (Thunks)</a></li>
                    <li><a href="#redux-store">27. Redux Store Structure</a></li>
                    <li><a href="#redux-slice">28. Redux Slice - State Management</a></li>
                    <li><a href="#redux-thunks">29. Redux Thunks - Async Actions</a></li>
                    <li><a href="#api-architecture">30. API Services Architecture</a></li>
                    <li><a href="#typescript-redux">31. TypeScript vs JavaScript in Redux</a></li>
                    <li><a href="#redux-complete-flow">32. Complete Redux Flow</a></li>
                    <li><a href="#redux-patterns">33. Redux Use Cases & Patterns</a></li>
                    <li><a href="#redux-mistakes">34. Common Redux Mistakes</a></li>
                    <li><a href="#redux-devtools">35. Redux DevTools Usage</a></li>
                    <li><a href="#redux-performance">36. Performance Optimization</a></li>
                </ul>
            </div>

            <!-- Section 1 -->
            <h2 id="why-react">1. Why React Exists - The Problem</h2>
            
            <h3>Traditional JavaScript (The Old Way)</h3>
            <pre><code>&lt;div id="counter"&gt;0&lt;/div&gt;
&lt;button id="btn"&gt;Click&lt;/button&gt;

&lt;script&gt;
let count = 0;
document.getElementById('btn').onclick = function() {
  count++;
  // MANUAL DOM UPDATE - You must remember to update HTML
  document.getElementById('counter').textContent = count;
};
&lt;/script&gt;</code></pre>

            <div class="error">
                <h4>Problems:</h4>
                <ul>
                    <li>You manually update the DOM</li>
                    <li>Easy to forget updating some parts</li>
                    <li>Hard to track what changed</li>
                    <li>Messy when app grows</li>
                </ul>
            </div>

            <h3>React's Solution</h3>
            <pre><code>function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;div&gt;{count}&lt;/div&gt; {/* React auto-updates this */}
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

            <div class="success">
                <strong>React automatically updates the UI when data changes!</strong>
            </div>

            <!-- Section 2 -->
            <h2 id="rerender">2. Core Concept: React Re-renders</h2>
            
            <div class="flow-diagram">
                <strong>The React Cycle:</strong><br>
                1. State changes → 2. Component re-runs → 3. React updates DOM
            </div>

            <h3>Example from Login Component</h3>
            <pre><code>const [showPassword, setShowPassword] = useState(false);

// When you click "Show" button:
setShowPassword(true); // 1. State changes
// 2. React re-runs entire Login function
// 3. React updates input type to "text"</code></pre>

            <!-- Section 3 -->
            <h2 id="state-props">3. State vs Props - The Fundamental Difference</h2>

            <h3>STATE = Component's Memory (Mutable)</h3>
            <pre><code>function Counter() {
  // State belongs to THIS component
  const [count, setCount] = useState(0);
  
  // This component OWNS and CONTROLS count
  return &lt;button onClick={() =&gt; setCount(count + 1)}&gt;{count}&lt;/button&gt;;
}</code></pre>

            <div class="info">
                <h4>State Characteristics:</h4>
                <ul>
                    <li>✅ Can be changed with <code>setState</code></li>
                    <li>✅ Belongs to the component</li>
                    <li>✅ Causes re-render when changed</li>
                    <li>✅ Persists between re-renders</li>
                </ul>
            </div>

            <h3>PROPS = Data Passed from Parent (Immutable)</h3>
            <pre><code>// Parent component
function App() {
  return &lt;Greeting name="John" age={25} /&gt;;
}

// Child component
function Greeting({ name, age }: { name: string, age: number }) {
  // Props are READ-ONLY
  // name = "Jane"; // ❌ ERROR! Cannot modify props
  
  return &lt;h1&gt;Hello {name}, you are {age}&lt;/h1&gt;;
}</code></pre>

            <div class="info">
                <h4>Props Characteristics:</h4>
                <ul>
                    <li>❌ <strong>CANNOT</strong> be modified by child</li>
                    <li>✅ Passed from parent to child</li>
                    <li>✅ Read-only (immutable)</li>
                    <li>✅ If parent changes props, child re-renders</li>
                </ul>
            </div>

            <!-- Section 4 -->
            <h2 id="immutability">4. Why Props are Immutable (React's Design Philosophy)</h2>

            <h3>The Problem Props Solve:</h3>
            <pre><code>// ❌ BAD: If children could modify props
function Parent() {
  const [name, setName] = useState("John");
  return &lt;Child name={name} /&gt;;
}

function Child({ name }) {
  name = "Jane"; // If this worked, Parent wouldn't know!
  // Parent still thinks name is "John" - DATA INCONSISTENCY!
}</code></pre>

            <h3>✅ GOOD: One-Way Data Flow</h3>
            <pre><code>// Parent controls the data
function Parent() {
  const [name, setName] = useState("John");
  return &lt;Child name={name} onChangeName={setName} /&gt;;
}

// Child requests changes through callback
function Child({ name, onChangeName }) {
  return &lt;button onClick={() =&gt; onChangeName("Jane")}&gt;{name}&lt;/button&gt;;
}</code></pre>

            <div class="highlight">
                <strong>React Rule:</strong> Data flows <strong>DOWN</strong> (props), events flow <strong>UP</strong> (callbacks)
            </div>

            <!-- Section 5 -->
            <h2 id="usestate">5. useState - Managing Component Memory</h2>

            <h3>How useState Works</h3>
            <pre><code>import { useState } from 'react';

function Login() {
  // useState returns [currentValue, functionToUpdate]
  const [username, setUsername] = useState('');
  //      ↑ current value    ↑ updater function    ↑ initial value
  
  return (
    &lt;input 
      value={username}
      onChange={(e) =&gt; setUsername(e.target.value)}
    /&gt;
  );
}</code></pre>

            <h3>What Happens Behind the Scenes:</h3>
            <div class="flow-diagram">
                <strong>First render:</strong><br>
                const [username, setUsername] = useState('');<br>
                → username = ''<br><br>

                <strong>User types "j":</strong><br>
                setUsername('j');<br>
                → React schedules re-render<br><br>

                <strong>Second render:</strong><br>
                const [username, setUsername] = useState('');<br>
                → useState ignores initial value, returns stored value<br>
                → username = 'j'<br><br>

                <strong>User types "o":</strong><br>
                setUsername('jo');<br>
                → React schedules re-render<br><br>

                <strong>Third render:</strong><br>
                → username = 'jo'
            </div>

            <h3>Real Example from Your Login:</h3>
            <pre><code>const [localUsername, setLocalUsername] = useState('');
const [localPassword, setLocalPassword] = useState('');
const [showPassword, setShowPassword] = useState(false);

// When user types in username field:
&lt;input
  value={localUsername}
  onChange={(e) =&gt; setLocalUsername(e.target.value)}
  // e.target.value = "nuwantha"
/&gt;

// Flow:
// 1. User types "n" → setLocalUsername('n')
// 2. React re-renders → localUsername = 'n'
// 3. Input shows "n"
// 4. User types "u" → setLocalUsername('nu')
// 5. React re-renders → localUsername = 'nu'
// 6. Input shows "nu"
// ...continues</code></pre>

            <!-- Section 6 -->
            <h2 id="why-usestate">6. Why We Need useState (The Trap)</h2>

            <h3>❌ WITHOUT useState (Doesn't Work):</h3>
            <pre><code>function Counter() {
  let count = 0; // Regular variable
  
  return (
    &lt;button onClick={() =&gt; {
      count++; // Variable changes
      console.log(count); // Logs: 1, 2, 3...
    }}&gt;
      {count} {/* UI always shows 0! */}
    &lt;/button&gt;
  );
}</code></pre>

            <div class="error">
                <h4>Why it fails:</h4>
                <ul>
                    <li>✅ Variable updates</li>
                    <li>❌ React doesn't know about it</li>
                    <li>❌ No re-render triggered</li>
                    <li>❌ UI never updates</li>
                </ul>
            </div>

            <h3>✅ WITH useState (Works):</h3>
            <pre><code>function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;button onClick={() =&gt; {
      setCount(count + 1); // Tells React "state changed"
    }}&gt;
      {count} {/* UI updates! */}
    &lt;/button&gt;
  );
}</code></pre>

            <div class="success">
                <h4>Why it works:</h4>
                <ul>
                    <li>✅ <code>setCount</code> tells React state changed</li>
                    <li>✅ React schedules re-render</li>
                    <li>✅ Component re-runs with new count</li>
                    <li>✅ UI updates</li>
                </ul>
            </div>

            <!-- Section 7 -->
            <h2 id="useeffect">7. useEffect - Handling Side Effects</h2>

            <h3>What are Side Effects?</h3>
            <p>Things <strong>outside</strong> the component's render:</p>
            <ul>
                <li>API calls (fetch data)</li>
                <li>Setting timers</li>
                <li>Subscribing to events</li>
                <li>Updating document title</li>
                <li>Reading from localStorage</li>
            </ul>

            <h3>The Problem Without useEffect:</h3>
            <pre><code>function BadComponent() {
  fetch('/api/data'); // ❌ RUNS EVERY RENDER!
  
  return &lt;div&gt;Hello&lt;/div&gt;;
}

// If state changes → re-render → fetch again → infinite loop!</code></pre>

            <h3>Solution: useEffect</h3>
            <pre><code>function GoodComponent() {
  const [data, setData] = useState(null);
  
  useEffect(() =&gt; {
    // This code runs AFTER render
    fetch('/api/data')
      .then(res =&gt; res.json())
      .then(data =&gt; setData(data));
  }, []); // Empty array = run once after first render
  
  return &lt;div&gt;{data}&lt;/div&gt;;
}</code></pre>

            <!-- Section 8 -->
            <h2 id="dependency-array">8. useEffect Dependency Array - The Rules</h2>

            <h3>Three Patterns:</h3>

            <h4>Pattern 1: Run Once (Component Mount)</h4>
            <pre><code>useEffect(() =&gt; {
  console.log('Component mounted');
  // Fetch initial data
  // Start WebSocket connection
}, []); // Empty array = run once</code></pre>

            <h4>Pattern 2: Run When Specific Value Changes</h4>
            <pre><code>const [userId, setUserId] = useState(1);

useEffect(() =&gt; {
  console.log('userId changed to:', userId);
  fetch(`/api/user/${userId}`);
}, [userId]); // Re-run when userId changes</code></pre>

            <h4>Pattern 3: Run After Every Render</h4>
            <pre><code>useEffect(() =&gt; {
  console.log('Component rendered');
  // Usually avoid this - performance issue
}); // No array = run every render</code></pre>

            <!-- Section 9 -->
            <h2 id="login-example">9. Real Example from Your Login Component</h2>

            <pre><code>const { isLoading, error, isAuthenticated } = useSelector(
  (state: RootState) =&gt; state.auth
);

useEffect(() =&gt; {
  if (isAuthenticated) {
    navigate('/dashboard', { replace: true });
  }
}, [isAuthenticated, navigate]);</code></pre>

            <div class="flow-diagram">
                <strong>What happens:</strong><br><br>
                1. User clicks "Sign In"<br>
                2. dispatch(loginUser(...)) called<br>
                3. Redux state changes: isAuthenticated = false → true<br>
                4. Login component re-renders (Redux caused it)<br>
                5. useEffect sees isAuthenticated changed<br>
                6. useEffect runs: navigate('/dashboard')<br>
                7. User redirected to dashboard
            </div>

            <div class="error">
                <h4>Without useEffect (Wrong):</h4>
                <pre><code>function Login() {
  if (isAuthenticated) {
    navigate('/dashboard'); // ❌ Runs during render - React error!
  }
}</code></pre>
            </div>

            <!-- Section 10 -->
            <h2 id="event-handling">10. Event Handling in React</h2>

            <h3>Traditional JavaScript:</h3>
            <pre><code>&lt;button onclick="handleClick()"&gt;Click&lt;/button&gt;</code></pre>

            <h3>React Way:</h3>
            <pre><code>&lt;button onClick={handleClick}&gt;Click&lt;/button&gt;
{/* Note: onClick (camelCase), {handleClick} (no quotes) */}</code></pre>

            <h3>Common Event Types:</h3>
            <pre><code>// Mouse events
&lt;button onClick={(e: React.MouseEvent) =&gt; console.log(e)}&gt;Click&lt;/button&gt;

// Form events
&lt;input onChange={(e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
  console.log(e.target.value);
}} /&gt;

// Form submission
&lt;form onSubmit={(e: FormEvent) =&gt; {
  e.preventDefault(); // Stop page reload
  console.log('Form submitted');
}}&gt;</code></pre>

            <h3>From Your Login:</h3>
            <pre><code>const onSubmit = (e: FormEvent) =&gt; {
  e.preventDefault(); // Stop browser from reloading page
  dispatch(loginUser({ 
    username: localUsername, 
    password: localPassword 
  }));
};

&lt;form onSubmit={onSubmit}&gt;
  {/* form fields */}
&lt;/form&gt;</code></pre>

            <!-- Section 11 -->
            <h2 id="controlled">11. Controlled vs Uncontrolled Components</h2>

            <h3>Controlled (React State Controls Input)</h3>
            <pre><code>function Login() {
  const [username, setUsername] = useState('');
  
  return (
    &lt;input
      value={username} // React controls this
      onChange={(e) =&gt; setUsername(e.target.value)} // Update state
    /&gt;
  );
}</code></pre>

            <div class="flow-diagram">
                <strong>Flow:</strong><br>
                User types "a" → onChange fires → setUsername('a') → <br>
                React re-renders → value={username} → Input shows "a"
            </div>

            <h3>Uncontrolled (Browser Controls Input)</h3>
            <pre><code>function Login() {
  const inputRef = useRef&lt;HTMLInputElement&gt;(null);
  
  const onSubmit = () =&gt; {
    console.log(inputRef.current?.value); // Read value when needed
  };
  
  return &lt;input ref={inputRef} /&gt;;
}</code></pre>

            <div class="highlight">
                <strong>Your Login uses Controlled inputs</strong> (better for validation)
            </div>

            <!-- Section 12 -->
            <h2 id="local-state">12. Why Local State in Login Component?</h2>

            <pre><code>// Local state for form inputs
const [localUsername, setLocalUsername] = useState('');
const [localPassword, setLocalPassword] = useState('');

// Redux state for authentication result
const { isLoading, error, isAuthenticated } = useSelector(
  (state: RootState) =&gt; state.auth
);</code></pre>

            <h3>Decision Tree:</h3>
            <div class="flow-diagram">
                Do multiple components need this data?<br>
                ├─ YES → Use Redux (isAuthenticated, user info)<br>
                └─ NO → Use local useState (form inputs)
            </div>

            <div class="info">
                <h4>Why not store username/password in Redux?</h4>
                <ul>
                    <li>❌ Only Login page needs them</li>
                    <li>❌ Don't want password in global state (security)</li>
                    <li>❌ Don't need them after login</li>
                    <li>✅ Local state is simpler and safer</li>
                </ul>
            </div>

            <!-- Section 13 -->
            <h2 id="render-cycle">13. React Render Cycle (Complete Picture)</h2>

            <pre><code>function Login() {
  const [username, setUsername] = useState('');
  console.log('1. Component function runs');
  
  useEffect(() =&gt; {
    console.log('3. Effect runs AFTER render');
  }, [username]);
  
  console.log('2. About to return JSX');
  return &lt;input 
    value={username} 
    onChange={e =&gt; setUsername(e.target.value)} 
  /&gt;;
}</code></pre>

            <div class="flow-diagram">
                <strong>When user types "a":</strong><br><br>
                1. Component function runs (username = '')<br>
                2. About to return JSX<br>
                   → React updates DOM<br>
                3. Effect runs AFTER render<br><br>

                4. User types "a" → setUsername('a')<br><br>
                   
                5. Component function runs (username = 'a')<br>
                6. About to return JSX<br>
                   → React updates DOM<br>
                7. Effect runs AFTER render (username changed)
            </div>

            <!-- Section 14 -->
            <h2 id="usestate-patterns">14. Common useState Patterns</h2>

            <h3>Pattern 1: Update Based on Previous State</h3>
            <pre><code>// ❌ WRONG: May lose updates
setCount(count + 1);

// ✅ CORRECT: Guaranteed to use latest
setCount(prevCount =&gt; prevCount + 1);</code></pre>

            <h3>Pattern 2: Toggle Boolean</h3>
            <pre><code>const [showPassword, setShowPassword] = useState(false);

// ✅ Toggle pattern
setShowPassword(prev =&gt; !prev);</code></pre>

            <h3>Pattern 3: Update Object State</h3>
            <pre><code>const [user, setUser] = useState({ name: '', age: 0 });

// ❌ WRONG: Loses other properties
setUser({ name: 'John' }); // age is gone!

// ✅ CORRECT: Spread existing properties
setUser(prev =&gt; ({ ...prev, name: 'John' }));</code></pre>

            <h3>Pattern 4: Update Array State</h3>
            <pre><code>const [items, setItems] = useState(['a', 'b']);

// Add item
setItems(prev =&gt; [...prev, 'c']); // ['a', 'b', 'c']

// Remove item
setItems(prev =&gt; prev.filter(item =&gt; item !== 'b')); // ['a', 'c']

// Update item
setItems(prev =&gt; prev.map(item =&gt; 
  item === 'a' ? 'x' : item
)); // ['x', 'b']</code></pre>

            <!-- Section 15 -->
            <h2 id="typescript">15. TypeScript Types in React</h2>

            <h3>Function Component Type:</h3>
            <pre><code>import { type FC } from 'react';

// Method 1: Inline props type
function Login({ onSuccess }: { onSuccess: () =&gt; void }) {
  return &lt;div&gt;Login&lt;/div&gt;;
}

// Method 2: Interface
interface LoginProps {
  onSuccess: () =&gt; void;
}

const Login: FC&lt;LoginProps&gt; = ({ onSuccess }) =&gt; {
  return &lt;div&gt;Login&lt;/div&gt;;
};</code></pre>

            <h3>Event Types:</h3>
            <pre><code>import { 
  type FormEvent, 
  type ChangeEvent, 
  type MouseEvent 
} from 'react';

// Form submit
const onSubmit = (e: FormEvent) =&gt; {
  e.preventDefault();
};

// Input change
const onChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
  console.log(e.target.value);
};

// Button click
const onClick = (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {
  console.log(e.currentTarget);
};</code></pre>

            <!-- Section 16 -->
            <h2 id="mental-model">16. Memory Aid: React Mental Model</h2>

            <div class="highlight" style="font-family: monospace; line-height: 2;">
                <strong>Component</strong> = Function that returns JSX<br><br>

                <strong>State</strong> = Component's memory (use useState)<br>
                <strong>Props</strong> = Data from parent (read-only)<br><br>

                When state changes → Component re-runs → React updates UI<br><br>

                <strong>useEffect</strong> = Run code AFTER render<br>
                &nbsp;&nbsp;- [] = run once (mount)<br>
                &nbsp;&nbsp;- [dep] = run when dep changes<br>
                &nbsp;&nbsp;- no array = run every render<br><br>

                <strong>Events</strong> = User interactions (onClick, onChange)<br>
                &nbsp;&nbsp;- Always preventDefault() on form submit<br>
                &nbsp;&nbsp;- Update state in event handlers<br><br>

                <strong>Controlled Input</strong> = React state controls value<br>
                &nbsp;&nbsp;- value={state}<br>
                &nbsp;&nbsp;- onChange={setState}
            </div>

            <!-- Section 17 -->
            <h2 id="complete-flow">17. Your Login Component - Complete Flow</h2>

            <div class="flow-diagram">
                <strong>Step-by-Step Execution:</strong><br><br>

                <strong>1-6. Initial Load:</strong><br>
                • User lands on /login<br>
                • Login component mounts<br>
                • useState initializes: localUsername='', localPassword='', showPassword=false<br>
                • useSelector reads Redux: isLoading=false, error=null, isAuthenticated=false<br>
                • useEffect checks isAuthenticated → false → does nothing<br>
                • Component renders login form<br><br>

                <strong>7-8. User Input:</strong><br>
                • User types username "nuwantha"<br>
                &nbsp;&nbsp;→ setLocalUsername called 9 times (each letter)<br>
                &nbsp;&nbsp;→ 9 re-renders → input updates live<br><br>

                • User types password "pass123"<br>
                &nbsp;&nbsp;→ setLocalPassword called 7 times<br>
                &nbsp;&nbsp;→ 7 re-renders → input updates (hidden as dots)<br><br>

                <strong>9. Form Submission:</strong><br>
                • User clicks "Sign In"<br>
                &nbsp;&nbsp;→ onSubmit called<br>
                &nbsp;&nbsp;→ e.preventDefault() stops page reload<br>
                &nbsp;&nbsp;→ dispatch(loginUser({ username: 'nuwantha', password: 'pass123' }))<br>
                &nbsp;&nbsp;→ Redux state changes: isLoading=true<br>
                &nbsp;&nbsp;→ Login re-renders → button shows "Signing In..." with spinner<br><br>

                <strong>10. Successful Authentication:</strong><br>
                • API responds successfully<br>
                &nbsp;&nbsp;→ Redux state: isLoading=false, isAuthenticated=true<br>
                &nbsp;&nbsp;→ Login re-renders<br>
                &nbsp;&nbsp;→ useEffect sees isAuthenticated=true<br>
                &nbsp;&nbsp;→ navigate('/dashboard') called<br>
                &nbsp;&nbsp;→ User redirected to dashboard
            </div>

            <!-- Comparison Table -->
            <h2>Quick Reference: State vs Props</h2>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>State (useState)</th>
                        <th>Props</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Mutability</strong></td>
                        <td>✅ Mutable (via setState)</td>
                        <td>❌ Immutable</td>
                    </tr>
                    <tr>
                        <td><strong>Ownership</strong></td>
                        <td>Owned by component</td>
                        <td>Passed from parent</td>
                    </tr>
                    <tr>
                        <td><strong>Triggers Re-render</strong></td>
                        <td>✅ Yes</td>
                        <td>✅ Yes (when parent updates)</td>
                    </tr>
                    <tr>
                        <td><strong>Persists Between Renders</strong></td>
                        <td>✅ Yes</td>
                        <td>✅ Yes</td>
                    </tr>
                    <tr>
                        <td><strong>Use Case</strong></td>
                        <td>Component's internal data</td>
                        <td>Passing data to children</td>
                    </tr>
                </tbody>
            </table>

            <!-- Hooks Comparison -->
            <h2>Hooks Quick Reference</h2>
            <table>
                <thead>
                    <tr>
                        <th>Hook</th>
                        <th>Purpose</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>useState</code></td>
                        <td>Component state</td>
                        <td><code>const [count, setCount] = useState(0)</code></td>
                    </tr>
                    <tr>
                        <td><code>useEffect</code></td>
                        <td>Side effects</td>
                        <td><code>useEffect(() => { fetch() }, [])</code></td>
                    </tr>
                    <tr>
                        <td><code>useSelector</code></td>
                        <td>Read Redux state</td>
                        <td><code>const user = useSelector(s => s.auth.user)</code></td>
                    </tr>
                    <tr>
                        <td><code>useDispatch</code></td>
                        <td>Update Redux state</td>
                        <td><code>dispatch(loginUser(credentials))</code></td>
                    </tr>
                    <tr>
                        <td><code>useNavigate</code></td>
                        <td>Navigation</td>
                        <td><code>navigate('/dashboard')</code></td>
                    </tr>
                    <tr>
                        <td><code>useRef</code></td>
                        <td>DOM reference</td>
                        <td><code>const inputRef = useRef(null)</code></td>
                    </tr>
                </tbody>
            </table>

            <!-- Key Takeaways -->
            <h2>🎯 Key Takeaways</h2>
            <div class="success">
                <ol>
                    <li><strong>React re-renders when state changes</strong> - This is the core mechanism</li>
                    <li><strong>useState for local data</strong> - Form inputs, UI toggles</li>
                    <li><strong>Props flow down</strong> - Parent to child, immutable</li>
                    <li><strong>useEffect for side effects</strong> - API calls, subscriptions</li>
                    <li><strong>Dependency array controls when effects run</strong> - Empty = once, [dep] = on change</li>
                    <li><strong>Controlled components</strong> - React state controls input values</li>
                    <li><strong>Redux for global state</strong> - Authentication, shared data</li>
                    <li><strong>TypeScript adds type safety</strong> - Catch errors at compile time</li>
                </ol>
            </div>

            <!-- Section 18: React Router -->
            <h2 id="routing">18. React Router - Navigation System</h2>

            <h3>What is React Router?</h3>
            <p>React Router enables navigation between different pages in a React application without reloading the browser.</p>

            <h3>The Problem Without Routing</h3>
            <pre><code>// ❌ Single page - everything in one component
function App() {
  const [page, setPage] = useState('login');
  
  if (page === 'login') return &lt;Login onLogin={() =&gt; setPage('dashboard')} /&gt;;
  if (page === 'dashboard') return &lt;Dashboard onLogout={() =&gt; setPage('login')} /&gt;;
  if (page === 'profile') return &lt;Profile /&gt;;
}</code></pre>

            <div class="error">
                <h4>Problems:</h4>
                <ul>
                    <li>❌ No URL changes (can't bookmark)</li>
                    <li>❌ Browser back button doesn't work</li>
                    <li>❌ Can't share links to specific pages</li>
                    <li>❌ No navigation history</li>
                </ul>
            </div>

            <h3>✅ React Router Solution</h3>
            <pre><code>import { createBrowserRouter, RouterProvider } from 'react-router-dom';

const router = createBrowserRouter([
  {
    path: '/',           // URL path
    element: &lt;Home /&gt;    // Component to render
  },
  {
    path: '/about',
    element: &lt;About /&gt;
  }
]);

function App() {
  return &lt;RouterProvider router={router} /&gt;;
}</code></pre>

            <div class="flow-diagram">
                <strong>Different URLs show different components:</strong><br>
                /login           → Login component<br>
                /dashboard       → Dashboard component<br>
                /profile         → Profile component<br>
                /leaves/apply    → ApplyLeave component
            </div>

            <h3>How React Router Works</h3>
            <div class="info">
                <strong>Flow:</strong> User visits /about → Router matches path → Renders &lt;About /&gt; component
            </div>

            <!-- Section 19: Protected Routes -->
            <h2 id="protected-routes">19. Protected Routes - Authentication Guards</h2>

            <h3>What is a Protected Route?</h3>
            <p>A <strong>Protected Route</strong> is a <strong>wrapper component</strong> that:</p>
            <ol>
                <li>Checks if user is authenticated</li>
                <li>If YES → Shows the page</li>
                <li>If NO → Redirects to login</li>
            </ol>

            <div class="highlight">
                <h4>Visual Analogy:</h4>
                <p><strong>Protected Route = Security Guard at Building Entrance</strong></p>
                <div class="flow-diagram">
                    User tries to enter Dashboard:<br>
                    ┌─────────────────────────────┐<br>
                    │   ProtectedRoute (Guard)    │<br>
                    │   "Show me your badge!"     │<br>
                    └─────────────────────────────┘<br>
                            ↓<br>
                       Has badge? (isAuthenticated)<br>
                            ↓<br>
                        ┌───┴───┐<br>
                       YES     NO<br>
                        ↓       ↓<br>
                      Enter   Redirect<br>
                    Dashboard to Login
                </div>
            </div>

            <h3>Is ProtectedRoute a Parent Class?</h3>
            <div class="error">
                <h4>Answer: NO - It's a Wrapper Component (Not Inheritance)</h4>
                <pre><code>// ProtectedRoute is NOT a parent class
// It's a component that wraps other components

&lt;ProtectedRoute&gt;        ← Wrapper
  &lt;Dashboard /&gt;         ← Child
&lt;/ProtectedRoute&gt;</code></pre>
                <p>In React:</p>
                <ul>
                    <li>❌ Not inheritance (no parent/child classes)</li>
                    <li>✅ Composition (wrapping components)</li>
                </ul>
            </div>

            <h3>Your ProtectedRoute Component - Line by Line</h3>
            <pre><code>import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { type RootState } from '../store/store';

interface ProtectedRouteProps {
  children?: React.ReactNode;  // Optional: component to protect
}

export default function ProtectedRoute({ children }: ProtectedRouteProps) {
  // Step 1: Check authentication status from Redux
  const { isAuthenticated, isLoading } = useSelector(
    (state: RootState) =&gt; state.auth
  );

  // Step 2: Show loading state while checking auth
  if (isLoading) {
    return (
      &lt;div className="d-flex justify-content-center align-items-center" 
           style={{ minHeight: '100vh' }}&gt;
        Loading...
      &lt;/div&gt;
    );
  }

  // Step 3: Not authenticated? Redirect to login
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" replace /&gt;;
    // "replace" removes this page from browser history
  }

  // Step 4: Authenticated! Render the protected content
  return children ? &lt;&gt;{children}&lt;/&gt; : &lt;Outlet /&gt;;
  // If children exist, render them
  // Otherwise, render nested routes (Outlet)
}</code></pre>

            <h3>Two Ways to Use ProtectedRoute</h3>

            <h4>Method 1: Wrapping Children (Your Current Approach)</h4>
            <pre><code>// routes.tsx
{
  path: '/dashboard',
  element: (
    &lt;ProtectedRoute&gt;
      &lt;Dashboard /&gt;
    &lt;/ProtectedRoute&gt;
  )
}

// ProtectedRoute.tsx
return children ? &lt;&gt;{children}&lt;/&gt; : &lt;Outlet /&gt;;
//     ↑ Dashboard component is passed here</code></pre>
            <p><strong>When to use:</strong> Single protected page, simple route structure</p>

            <h4>Method 2: Using Outlet (Nested Routes)</h4>
            <pre><code>// routes.tsx
{
  path: '/',
  element: &lt;ProtectedRoute /&gt;,  // No children
  children: [                    // Nested routes
    { path: 'dashboard', element: &lt;Dashboard /&gt; },
    { path: 'profile', element: &lt;Profile /&gt; },
    { path: 'leaves', element: &lt;Leaves /&gt; }
  ]
}

// ProtectedRoute.tsx
return &lt;Outlet /&gt;;  // Renders nested route's element</code></pre>
            <p><strong>When to use:</strong> Multiple protected pages, shared layout, better organization</p>

            <!-- Section 20: Route Structure -->
            <h2 id="route-structure">20. Route Structure Best Practices</h2>

            <h3>Complete Route Setup Example</h3>
            <pre><code>import { createBrowserRouter, Navigate } from 'react-router-dom';
import Login from '../pages/login/Login';
import Dashboard from '../pages/dashboard/Dashboard';
import Profile from '../pages/profile/Profile';
import ApplyLeave from '../pages/leaves/ApplyLeave';
import LeaveHistory from '../pages/leaves/LeaveHistory';
import NotFound from '../pages/NotFound';
import ProtectedRoute from './ProtectedRoute';
import MainLayout from '../layouts/MainLayout';

export const router = createBrowserRouter([
  // Public routes
  {
    path: '/login',
    element: &lt;Login /&gt;
  },
  
  // Protected routes with shared layout
  {
    path: '/',
    element: &lt;ProtectedRoute /&gt;,  // Guard for all nested routes
    children: [
      {
        element: &lt;MainLayout /&gt;,  // Shared layout (sidebar, header)
        children: [
          {
            index: true,  // Default route when visiting "/"
            element: &lt;Navigate to="/dashboard" replace /&gt;
          },
          {
            path: 'dashboard',
            element: &lt;Dashboard /&gt;
          },
          {
            path: 'profile',
            element: &lt;Profile /&gt;
          },
          {
            path: 'leaves',
            children: [
              {
                path: 'apply',
                element: &lt;ApplyLeave /&gt;
              },
              {
                path: 'history',
                element: &lt;LeaveHistory /&gt;
              }
            ]
          }
        ]
      }
    ]
  },
  
  // 404 page
  {
    path: '*',
    element: &lt;NotFound /&gt;
  }
]);</code></pre>

            <h3>Route Tree Visualization</h3>
            <div class="flow-diagram">
                / (ProtectedRoute)<br>
                  └─ MainLayout<br>
                      ├─ /dashboard<br>
                      ├─ /profile<br>
                      └─ /leaves<br>
                          ├─ /leaves/apply<br>
                          └─ /leaves/history<br><br>

                /login (Public)<br>
                /* (404 Not Found)
            </div>

            <!-- Section 21: Navigate & Outlet -->
            <h2 id="navigate-outlet">21. Navigate & Outlet Components</h2>

            <h3>Navigate Component Explained</h3>
            <pre><code>if (!isAuthenticated) {
  return &lt;Navigate to="/login" replace /&gt;;
}</code></pre>

            <h4>What &lt;Navigate /&gt; Does</h4>
            <pre><code>&lt;Navigate to="/login" /&gt;
// Programmatically redirects to /login
// Like clicking a link, but automatic

&lt;Navigate to="/login" replace /&gt;
// "replace" option removes current page from history</code></pre>

            <h4>Example: With vs Without replace</h4>
            <div class="flow-diagram">
                <strong>Without replace:</strong><br>
                User visits /dashboard → Redirected to /login<br>
                Browser history: [/dashboard, /login]<br>
                User clicks back → Goes to /dashboard → Redirected to /login (loop!)<br><br>

                <strong>With replace:</strong><br>
                User visits /dashboard → Redirected to /login<br>
                Browser history: [/login]  ← /dashboard removed<br>
                User clicks back → Goes to previous page (before /dashboard)
            </div>

            <h3>Outlet Component Explained</h3>
            <pre><code>return children ? &lt;&gt;{children}&lt;/&gt; : &lt;Outlet /&gt;;</code></pre>

            <p><code>&lt;Outlet /&gt;</code> is a <strong>placeholder</strong> for nested route content.</p>

            <h4>Layout Component Example</h4>
            <pre><code>// Layout component
function MainLayout() {
  return (
    &lt;div&gt;
      &lt;Sidebar /&gt;
      &lt;div className="main-content"&gt;
        &lt;Outlet /&gt;  {/* Child route renders here */}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Route config
{
  element: &lt;MainLayout /&gt;,
  children: [
    { path: 'dashboard', element: &lt;Dashboard /&gt; },
    { path: 'profile', element: &lt;Profile /&gt; }
  ]
}</code></pre>

            <h4>Visual Representation</h4>
            <div class="flow-diagram">
                <strong>URL: /dashboard</strong><br>
                ┌─────────────────────┐<br>
                │ Sidebar             │<br>
                │ ┌─────────────────┐ │<br>
                │ │ &lt;Dashboard /&gt;   │ │ ← Outlet renders this<br>
                │ │                 │ │<br>
                │ └─────────────────┘ │<br>
                └─────────────────────┘<br><br>

                <strong>URL: /profile</strong><br>
                ┌─────────────────────┐<br>
                │ Sidebar             │<br>
                │ ┌─────────────────┐ │<br>
                │ │ &lt;Profile /&gt;     │ │ ← Outlet renders this<br>
                │ │                 │ │<br>
                │ └─────────────────┘ │<br>
                └─────────────────────┘
            </div>

            <!-- Section 22: Navigation Methods -->
            <h2 id="navigation-methods">22. Navigation Methods</h2>

            <h3>Method 1: Link Component</h3>
            <pre><code>import { Link } from 'react-router-dom';

function Sidebar() {
  return (
    &lt;nav&gt;
      &lt;Link to="/dashboard"&gt;Dashboard&lt;/Link&gt;
      &lt;Link to="/profile"&gt;Profile&lt;/Link&gt;
      &lt;Link to="/leaves/apply"&gt;Apply Leave&lt;/Link&gt;
    &lt;/nav&gt;
  );
}</code></pre>

            <h3>Method 2: useNavigate Hook</h3>
            <pre><code>import { useNavigate } from 'react-router-dom';

function Dashboard() {
  const navigate = useNavigate();
  
  const handleLogout = () =&gt; {
    dispatch(logout());
    navigate('/login');  // Programmatic navigation
  };
  
  return &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;;
}</code></pre>

            <h3>Method 3: Navigate Component</h3>
            <pre><code>function Home() {
  const { isAuthenticated } = useSelector(state =&gt; state.auth);
  
  if (isAuthenticated) {
    return &lt;Navigate to="/dashboard" /&gt;;  // Declarative redirect
  }
  
  return &lt;div&gt;Home Page&lt;/div&gt;;
}</code></pre>

            <!-- Section 23: Role-Based Protection -->
            <h2 id="role-based">23. Role-Based Protection (Advanced)</h2>

            <h3>Protecting Routes by User Role</h3>
            <pre><code>import { Navigate } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { type RootState } from '../store/store';

interface RoleProtectedRouteProps {
  children: React.ReactNode;
  allowedRoles: string[];  // ['admin', 'manager']
}

export default function RoleProtectedRoute({ 
  children, 
  allowedRoles 
}: RoleProtectedRouteProps) {
  const { isAuthenticated, user } = useSelector(
    (state: RootState) =&gt; state.auth
  );
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" replace /&gt;;
  }
  
  // Check if user's role is allowed
  if (!user || !allowedRoles.includes(user.role)) {
    return &lt;Navigate to="/unauthorized" replace /&gt;;
  }
  
  return &lt;&gt;{children}&lt;/&gt;;
}</code></pre>

            <h3>Usage Example</h3>
            <pre><code>// routes.tsx
{
  path: '/admin/users',
  element: (
    &lt;RoleProtectedRoute allowedRoles={['admin']}&gt;
      &lt;UserManagement /&gt;
    &lt;/RoleProtectedRoute&gt;
  )
}

{
  path: '/manager/approve-leaves',
  element: (
    &lt;RoleProtectedRoute allowedRoles={['admin', 'manager']}&gt;
      &lt;ApproveLeaves /&gt;
    &lt;/RoleProtectedRoute&gt;
  )
}</code></pre>

            <!-- Section 24: Complete Routing Flow -->
            <h2 id="routing-flow">24. Complete Routing Flow: Login to Dashboard</h2>

            <div class="flow-diagram">
                <strong>Complete Navigation Flow:</strong><br><br>

                <strong>1-4. App Initialization:</strong><br>
                • App starts → main.tsx runs<br>
                • RouterProvider loads → Checks URL<br>
                • URL is "/" → Redirects to "/login"<br>
                • Login component renders<br><br>

                <strong>5-8. Authentication:</strong><br>
                • User enters credentials → Clicks "Sign In"<br>
                • dispatch(loginUser(...)) called<br>
                • API call to backend<br>
                • Success → Redux updates: isAuthenticated = true<br><br>

                <strong>9-11. Navigation Triggered:</strong><br>
                • useEffect in Login component detects isAuthenticated = true<br>
                • navigate('/dashboard') called<br>
                • URL changes to "/dashboard"<br><br>

                <strong>12-16. Protected Route Check:</strong><br>
                • Router matches path="/dashboard"<br>
                • Renders &lt;ProtectedRoute&gt;&lt;Dashboard /&gt;&lt;/ProtectedRoute&gt;<br>
                • ProtectedRoute runs:<br>
                &nbsp;&nbsp;- useSelector reads: isAuthenticated = true ✓<br>
                &nbsp;&nbsp;- isLoading = false ✓<br>
                &nbsp;&nbsp;- Returns children (Dashboard)<br>
                • Dashboard component renders<br>
                • User sees dashboard page
            </div>

            <h2>Why Use Protected Routes?</h2>

            <h3>❌ WITHOUT Protected Routes (Bad Practice)</h3>
            <pre><code>// Every component needs auth check - CODE DUPLICATION
function Dashboard() {
  const { isAuthenticated } = useSelector((state) =&gt; state.auth);
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" /&gt;;  // Repeated in every component!
  }
  
  return &lt;div&gt;Dashboard content&lt;/div&gt;;
}

function Profile() {
  const { isAuthenticated } = useSelector((state) =&gt; state.auth);
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" /&gt;;  // Copy-paste code!
  }
  
  return &lt;div&gt;Profile content&lt;/div&gt;;
}

// 10 more components... 10 more copies!</code></pre>

            <div class="error">
                <h4>Problems:</h4>
                <ul>
                    <li>❌ Code duplication</li>
                    <li>❌ Easy to forget protection</li>
                    <li>❌ Hard to maintain</li>
                    <li>❌ Security risk if you forget</li>
                </ul>
            </div>

            <h3>✅ WITH Protected Routes (Best Practice)</h3>
            <pre><code>// Protection logic in ONE place
function ProtectedRoute({ children }) {
  const { isAuthenticated } = useSelector((state) =&gt; state.auth);
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" /&gt;;
  }
  
  return &lt;&gt;{children}&lt;/&gt;;
}

// Components stay clean
function Dashboard() {
  return &lt;div&gt;Dashboard content&lt;/div&gt;;  // No auth check needed!
}

function Profile() {
  return &lt;div&gt;Profile content&lt;/div&gt;;  // No auth check needed!
}</code></pre>

            <div class="success">
                <h4>Benefits:</h4>
                <ul>
                    <li>✅ DRY (Don't Repeat Yourself)</li>
                    <li>✅ Centralized security logic</li>
                    <li>✅ Easier to maintain</li>
                    <li>✅ Harder to make mistakes</li>
                </ul>
            </div>

            <h2>Best Practices Checklist</h2>

            <h3>✅ DO:</h3>
            <table>
                <thead>
                    <tr>
                        <th>Practice</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Use ProtectedRoute for authenticated pages</td>
                        <td><code>&lt;ProtectedRoute&gt;&lt;Dashboard /&gt;&lt;/ProtectedRoute&gt;</code></td>
                    </tr>
                    <tr>
                        <td>Use replace on redirects</td>
                        <td><code>&lt;Navigate to="/login" replace /&gt;</code></td>
                    </tr>
                    <tr>
                        <td>Show loading state while checking auth</td>
                        <td><code>if (isLoading) return &lt;LoadingSpinner /&gt;;</code></td>
                    </tr>
                    <tr>
                        <td>Use nested routes for shared layouts</td>
                        <td><code>{ element: &lt;MainLayout /&gt;, children: [...] }</code></td>
                    </tr>
                    <tr>
                        <td>Create role-based routes</td>
                        <td><code>&lt;RoleProtectedRoute allowedRoles={['admin']}&gt;</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>❌ DON'T:</h3>
            <table>
                <thead>
                    <tr>
                        <th>Anti-Pattern</th>
                        <th>Why It's Bad</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Repeat auth checks in every component</td>
                        <td>Code duplication, hard to maintain</td>
                    </tr>
                    <tr>
                        <td>Forget to protect new routes</td>
                        <td>Security vulnerability</td>
                    </tr>
                    <tr>
                        <td>Use window.location for navigation</td>
                        <td>Causes full page reload, loses React state</td>
                    </tr>
                    <tr>
                        <td>Navigate during render without useEffect</td>
                        <td>React error: side effect during render</td>
                    </tr>
                </tbody>
            </table>

            <h2>Common Routing Patterns</h2>

            <h3>Pattern 1: Public Only Routes (Login/Register)</h3>
            <pre><code>function PublicOnlyRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated } = useSelector((state: RootState) =&gt; state.auth);
  
  // If already logged in, redirect to dashboard
  if (isAuthenticated) {
    return &lt;Navigate to="/dashboard" replace /&gt;;
  }
  
  return &lt;&gt;{children}&lt;/&gt;;
}

// Usage:
{
  path: '/login',
  element: (
    &lt;PublicOnlyRoute&gt;
      &lt;Login /&gt;
    &lt;/PublicOnlyRoute&gt;
  )
}</code></pre>

            <h3>Pattern 2: Conditional Redirects</h3>
            <pre><code>{
  path: '/',
  element: &lt;Navigate to={isAuthenticated ? '/dashboard' : '/login'} replace /&gt;
}</code></pre>

            <h3>Pattern 3: 404 Not Found</h3>
            <pre><code>{
  path: '*',  // Matches any unmatched route
  element: &lt;NotFound /&gt;
}</code></pre>

            <h2>Testing Your Routes</h2>

            <h3>URLs to Test</h3>
            <div class="info">
                <strong>Before Login:</strong>
                <ul>
                    <li>✅ /login → Should show login page</li>
                    <li>✅ /dashboard → Should redirect to /login (if not logged in)</li>
                    <li>✅ / → Should redirect to /login or /dashboard</li>
                    <li>✅ /random-url → Should show 404 page</li>
                </ul>

                <strong>After Login:</strong>
                <ul>
                    <li>✅ Visit /login → Should redirect to /dashboard</li>
                    <li>✅ Browser back button → Should work correctly</li>
                    <li>✅ Manual URL change → Should maintain auth state</li>
                    <li>✅ Page refresh → Should stay authenticated (redux-persist)</li>
                </ul>
            </div>

            <h2>Visual Summary: Routing Architecture</h2>
            <div class="flow-diagram">
┌─────────────────────────────────────────────────────┐<br>
│                    React Router                      │<br>
│                                                      │<br>
│  User visits URL → Router matches path              │<br>
│                  → Renders element                   │<br>
│                                                      │<br>
│  Public Routes:                                      │<br>
│    /login → &lt;Login /&gt;                               │<br>
│                                                      │<br>
│  Protected Routes:                                   │<br>
│    /dashboard → &lt;ProtectedRoute&gt;                    │<br>
│                   ├─ Check isAuthenticated          │<br>
│                   ├─ YES → &lt;Dashboard /&gt;            │<br>
│                   └─ NO  → &lt;Navigate to="/login" /&gt; │<br>
│                                                      │<br>
│  Nested Protected Routes:                           │<br>
│    / → &lt;ProtectedRoute /&gt;                           │<br>
│         └─ &lt;Outlet /&gt;                               │<br>
│              ├─ /dashboard                          │<br>
│              ├─ /profile                            │<br>
│              └─ /leaves/apply                       │<br>
└─────────────────────────────────────────────────────┘
            </div>

            <!-- Section 25: Synchronous vs Asynchronous -->
            <h2 id="sync-async">25. Synchronous vs Asynchronous Programming</h2>

            <h3>Synchronous Code (Blocking)</h3>
            <pre><code>console.log('1. Start');
const result = 2 + 2;  // Happens immediately
console.log('2. Result:', result);
console.log('3. End');

// Output (in order):
// 1. Start
// 2. Result: 4
// 3. End</code></pre>

            <div class="info">
                <h4>Synchronous Characteristics:</h4>
                <ul>
                    <li>✅ Executes line by line</li>
                    <li>✅ Waits for each line to finish</li>
                    <li>✅ Predictable order</li>
                    <li>❌ Blocks execution (freezes app if slow)</li>
                </ul>
            </div>

            <h3>Asynchronous Code (Non-Blocking)</h3>
            <pre><code>console.log('1. Start');

// Fetch data from server (takes 2 seconds)
fetch('/api/users')
  .then(data =&gt; console.log('2. Got data:', data));

console.log('3. End');

// Output (NOT in order):
// 1. Start
// 3. End              ← Runs immediately
// 2. Got data: [...]  ← Runs after 2 seconds</code></pre>

            <div class="info">
                <h4>Asynchronous Characteristics:</h4>
                <ul>
                    <li>✅ Doesn't block execution</li>
                    <li>✅ App stays responsive</li>
                    <li>✅ Perfect for API calls, timers</li>
                    <li>⚠️ Order is unpredictable</li>
                </ul>
            </div>

            <h3>Real-World Analogy</h3>
            <div class="flow-diagram">
                <strong>SYNCHRONOUS = Restaurant Counter</strong><br>
                ├─ Order food<br>
                ├─ Wait standing there (blocking)<br>
                └─ Get food → Leave<br><br>

                <strong>ASYNCHRONOUS = Restaurant with Buzzer</strong><br>
                ├─ Order food<br>
                ├─ Get buzzer (promise)<br>
                ├─ Sit down, use phone (non-blocking)<br>
                └─ Buzzer rings → Get food
            </div>

            <!-- Section 26: Why Redux Needs Async -->
            <h2 id="why-redux-async">26. Why Redux Needs Async (The Problem)</h2>

            <h3>Redux Rules (Synchronous Only)</h3>
            <pre><code>// Redux reducers MUST be synchronous
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;  // ✅ Synchronous - works
    },
    
    // ❌ CANNOT DO THIS IN REDUCER:
    async fetchAndIncrement(state) {
      const data = await fetch('/api/count');  // ❌ Async - breaks Redux
      state.value = data.count;
    }
  }
});</code></pre>

            <div class="error">
                <h4>Why reducers must be synchronous:</h4>
                <ul>
                    <li>State updates must be predictable</li>
                    <li>Time-travel debugging requires instant state changes</li>
                    <li>No side effects allowed (API calls, timers, etc.)</li>
                </ul>
            </div>

            <h3>Solution: Redux Thunks</h3>
            <pre><code>// Thunks handle async logic OUTSIDE reducers
// Then dispatch synchronous actions to update state

export const fetchAndIncrement = createAsyncThunk(
  'counter/fetchAndIncrement',
  async () =&gt; {
    const response = await fetch('/api/count');  // ✅ Async allowed here
    const data = await response.json();
    return data.count;
  }
);

// Reducer handles the RESULT synchronously
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0, isLoading: false },
  extraReducers: (builder) =&gt; {
    builder
      .addCase(fetchAndIncrement.pending, (state) =&gt; {
        state.isLoading = true;  // Synchronous update
      })
      .addCase(fetchAndIncrement.fulfilled, (state, action) =&gt; {
        state.value = action.payload;  // Synchronous update
        state.isLoading = false;
      });
  }
});</code></pre>

            <!-- Section 27: Redux Store Structure -->
            <h2 id="redux-store">27. Redux Store Structure</h2>

            <h3>Your Store Configuration</h3>
            <pre><code>import { configureStore } from '@reduxjs/toolkit';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage'; // localStorage
import authReducer from '../features/auth/authSlice';

// Persist configuration
const persistConfig = {
  key: 'root',           // Key in localStorage
  storage,               // Use localStorage
  whitelist: ['auth']    // Only persist auth state
};

// Wrap auth reducer with persistence
const persistedAuthReducer = persistReducer(persistConfig, authReducer);

// Create Redux store
export const store = configureStore({
  reducer: {
    auth: persistedAuthReducer,  // auth slice saved to localStorage
    leaves: leavesReducer,       // leaves slice (not persisted)
    users: usersReducer          // users slice (not persisted)
  },
  middleware: (getDefaultMiddleware) =&gt;
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore redux-persist actions
        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE']
      }
    })
});

// Create persistor for PersistGate
export const persistor = persistStore(store);

// TypeScript types
export type RootState = ReturnType&lt;typeof store.getState&gt;;
export type AppDispatch = typeof store.dispatch;</code></pre>

            <h3>What Happens on App Start</h3>
            <div class="flow-diagram">
                <strong>Redux-Persist Flow:</strong><br><br>
                1. App starts<br>
                2. PersistGate checks localStorage for key "root"<br>
                3. Finds saved auth state: { user: {...}, isAuthenticated: true }<br>
                4. Rehydrates Redux store with saved data<br>
                5. User is auto-logged in!<br><br>

                <strong>Without persist:</strong><br>
                Page refresh → Redux state resets → User logged out
            </div>

            <!-- Section 28: Redux Slice -->
            <h2 id="redux-slice">28. Redux Slice - State Management</h2>

            <h3>Auth Slice Structure</h3>
            <pre><code>import { createSlice, type PayloadAction } from '@reduxjs/toolkit';
import { loginUser, logoutUser } from './authThunks';

// Define the shape of auth state
interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

// Initial state
const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null
};

// Create slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  
  // Synchronous actions
  reducers: {
    clearError(state) {
      state.error = null;
    },
    
    setUser(state, action: PayloadAction&lt;User&gt;) {
      state.user = action.payload;
      state.isAuthenticated = true;
    }
  },
  
  // Async actions (thunks)
  extraReducers: (builder) =&gt; {
    builder
      // loginUser thunk
      .addCase(loginUser.pending, (state) =&gt; {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) =&gt; {
        state.isLoading = false;
        state.isAuthenticated = true;
        state.user = action.payload;
        state.error = null;
      })
      .addCase(loginUser.rejected, (state, action) =&gt; {
        state.isLoading = false;
        state.isAuthenticated = false;
        state.user = null;
        state.error = action.payload as string;
      })
      
      // logoutUser thunk
      .addCase(logoutUser.fulfilled, (state) =&gt; {
        state.user = null;
        state.isAuthenticated = false;
        state.error = null;
      });
  }
});

export const { clearError, setUser } = authSlice.actions;
export default authSlice.reducer;</code></pre>

            <h3>State Flow Visualization</h3>
            <div class="flow-diagram">
                <strong>Initial State:</strong><br>
                { user: null, isAuthenticated: false, isLoading: false, error: null }<br><br>

                <strong>User clicks "Sign In":</strong><br>
                → dispatch(loginUser({ username, password }))<br>
                → loginUser.pending fires<br>
                → State: { isLoading: true, error: null }<br><br>

                <strong>API call succeeds:</strong><br>
                → loginUser.fulfilled fires<br>
                → State: { user: {...}, isAuthenticated: true, isLoading: false }<br><br>

                <strong>API call fails:</strong><br>
                → loginUser.rejected fires<br>
                → State: { error: "Invalid credentials", isLoading: false }
            </div>

            <!-- Section 29: Redux Thunks -->
            <h2 id="redux-thunks">29. Redux Thunks - Async Actions</h2>

            <h3>What is a Thunk?</h3>
            <p>A <strong>thunk</strong> is a function that:</p>
            <ol>
                <li>Makes async API calls</li>
                <li>Dispatches actions based on results</li>
                <li>Returns data to the reducer</li>
            </ol>

            <h3>Your loginUser Thunk</h3>
            <pre><code>import { createAsyncThunk } from '@reduxjs/toolkit';
import { authAPI } from '../../services/api';
import { toast } from 'react-toastify';

interface LoginCredentials {
  username: string;
  password: string;
}

interface User {
  id: string;
  username: string;
  email: string;
  role: string;
}

// Create async thunk
export const loginUser = createAsyncThunk&lt;
  User,                    // Return type (fulfilled)
  LoginCredentials,        // Argument type
  { rejectValue: string }  // Reject type (error)
&gt;(
  'auth/login',  // Action type prefix
  
  async (credentials, { rejectWithValue }) =&gt; {
    try {
      // API call (async operation)
      const response = await authAPI.login(credentials);
      
      // Success notification
      toast.success('Login successful!');
      
      // Return user data (goes to fulfilled case)
      return response.data.user;
      
    } catch (error: any) {
      // Error notification
      toast.error(error.response?.data?.message || 'Login failed');
      
      // Return error (goes to rejected case)
      return rejectWithValue(error.response?.data?.message || 'Login failed');
    }
  }
);

export const logoutUser = createAsyncThunk(
  'auth/logout',
  async () =&gt; {
    await authAPI.logout();
    toast.info('Logged out successfully');
  }
);</code></pre>

            <h3>Thunk Lifecycle</h3>
            <div class="flow-diagram">
                <strong>1. Component dispatches thunk:</strong><br>
                &nbsp;&nbsp;dispatch(loginUser({ username: 'john', password: 'pass123' }))<br><br>

                <strong>2. Thunk starts executing:</strong><br>
                &nbsp;&nbsp;→ loginUser.pending action dispatched<br>
                &nbsp;&nbsp;→ Reducer sets isLoading = true<br><br>

                <strong>3. Async operation runs:</strong><br>
                &nbsp;&nbsp;→ await authAPI.login(credentials)<br>
                &nbsp;&nbsp;→ Takes 2 seconds...<br><br>

                <strong>4a. Success path:</strong><br>
                &nbsp;&nbsp;&nbsp;&nbsp;→ return response.data.user<br>
                &nbsp;&nbsp;&nbsp;&nbsp;→ loginUser.fulfilled action dispatched<br>
                &nbsp;&nbsp;&nbsp;&nbsp;→ Reducer sets user and isAuthenticated<br><br>

                <strong>4b. Error path:</strong><br>
                &nbsp;&nbsp;&nbsp;&nbsp;→ return rejectWithValue('Invalid credentials')<br>
                &nbsp;&nbsp;&nbsp;&nbsp;→ loginUser.rejected action dispatched<br>
                &nbsp;&nbsp;&nbsp;&nbsp;→ Reducer sets error message
            </div>

            <!-- Section 30: API Services -->
            <h2 id="api-architecture">30. API Services Architecture</h2>

            <h3>Axios Instance Configuration</h3>
            <pre><code>import axios, { type AxiosInstance } from 'axios';

// Create axios instance with base configuration
const apiClient: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080/api',
  timeout: 10000,  // 10 second timeout
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor (add auth token to every request)
apiClient.interceptors.request.use(
  (config) =&gt; {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) =&gt; Promise.reject(error)
);

// Response interceptor (handle errors globally)
apiClient.interceptors.response.use(
  (response) =&gt; response,
  (error) =&gt; {
    if (error.response?.status === 401) {
      // Unauthorized - redirect to login
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;</code></pre>

            <h3>API Endpoints Organization</h3>
            <pre><code>// Auth API endpoints
export const authAPI = {
  login: (credentials: { username: string; password: string }) =&gt;
    apiClient.post('/auth/login', credentials),
  
  logout: () =&gt;
    apiClient.post('/auth/logout'),
  
  refreshToken: () =&gt;
    apiClient.post('/auth/refresh')
};

// Leave API endpoints
export const leaveAPI = {
  getAll: () =&gt;
    apiClient.get('/leaves'),
  
  getById: (id: string) =&gt;
    apiClient.get(`/leaves/${id}`),
  
  create: (data: LeaveRequest) =&gt;
    apiClient.post('/leaves', data),
  
  update: (id: string, data: LeaveRequest) =&gt;
    apiClient.put(`/leaves/${id}`, data),
  
  delete: (id: string) =&gt;
    apiClient.delete(`/leaves/${id}`)
};

// User API endpoints
export const userAPI = {
  getProfile: () =&gt;
    apiClient.get('/users/profile'),
  
  updateProfile: (data: UserProfile) =&gt;
    apiClient.put('/users/profile', data)
};</code></pre>

            <h3>API Flow Diagram</h3>
            <div class="flow-diagram">
Component<br>
  ↓ dispatch(loginUser({...}))<br>
Thunk (authThunks.ts)<br>
  ↓ authAPI.login(...)<br>
API Service (api.ts)<br>
  ↓ axios.post('/auth/login', ...)<br>
  ↓ Request Interceptor (adds token)<br>
HTTP Request → Backend<br>
  ↓<br>
Backend Response<br>
  ↓ Response Interceptor (checks 401)<br>
API Service<br>
  ↓ return response.data<br>
Thunk<br>
  ↓ return user data<br>
Reducer<br>
  ↓ state.user = action.payload<br>
Component re-renders with new state
            </div>

            <!-- Section 31: TypeScript vs JavaScript in Redux -->
            <h2 id="typescript-redux">31. TypeScript vs JavaScript in Redux</h2>

            <h3>JavaScript Redux (Loose Types)</h3>
            <pre><code>// ❌ JavaScript - No type safety
const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    isAuthenticated: false
  },
  reducers: {
    setUser(state, action) {
      state.user = action.payload;  // Could be anything!
      state.isAuthenticated = true;
    }
  }
});

// Usage - errors happen at runtime
dispatch(setUser('invalid'));  // Should be object, but it's a string!
dispatch(setUser({ name: 123 }));  // name should be string!</code></pre>

            <h3>TypeScript Redux (Type Safety)</h3>
            <pre><code>// ✅ TypeScript - Compile-time errors
interface User {
  id: string;
  username: string;
  email: string;
  role: 'admin' | 'user' | 'manager';
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
}

const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    isAuthenticated: false
  } as AuthState,
  reducers: {
    setUser(state, action: PayloadAction&lt;User&gt;) {
      state.user = action.payload;
      state.isAuthenticated = true;
    }
  }
});

// Usage - errors caught before running
dispatch(setUser('invalid'));  // ❌ TypeScript error!
dispatch(setUser({ name: 123 }));  // ❌ TypeScript error!
dispatch(setUser({ 
  id: '1', 
  username: 'john', 
  email: 'j@ex.com', 
  role: 'admin' 
}));  // ✅</code></pre>

            <h3>TypeScript Benefits in Redux</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Example</th>
                        <th>Benefit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Typed State Selection</td>
                        <td><code>const user = useSelector((state: RootState) =&gt; state.auth.user)</code></td>
                        <td>TypeScript knows user is User | null</td>
                    </tr>
                    <tr>
                        <td>Typed Dispatch</td>
                        <td><code>dispatch(loginUser({ username: 'john', password: '123' }))</code></td>
                        <td>Wrong property names caught at compile time</td>
                    </tr>
                    <tr>
                        <td>Typed Thunk Arguments</td>
                        <td><code>createAsyncThunk&lt;User, LoginCredentials&gt;(...)</code></td>
                        <td>Auto-complete for credentials properties</td>
                    </tr>
                    <tr>
                        <td>Typed Reducer Cases</td>
                        <td><code>action.payload</code> is typed as User</td>
                        <td>Auto-complete and type checking</td>
                    </tr>
                </tbody>
            </table>

            <!-- Section 32: Complete Redux Flow -->
            <h2 id="redux-complete-flow">32. Complete Redux Flow in Your Login</h2>

            <div class="flow-diagram">
                <strong>Complete Login to Dashboard Flow:</strong><br><br>

                <strong>1. User clicks "Sign In" button</strong><br>
                &lt;form onSubmit={onSubmit}&gt;<br>
                  &lt;button type="submit"&gt;Sign In&lt;/button&gt;<br>
                &lt;/form&gt;<br><br>

                <strong>2. onSubmit handler fires</strong><br>
                const onSubmit = (e: FormEvent) =&gt; {<br>
                  e.preventDefault();<br>
                  dispatch(loginUser({ username, password }));<br>
                };<br><br>

                <strong>3. loginUser thunk starts</strong><br>
                → pending action dispatched<br>
                → Reducer: state.isLoading = true<br>
                → Component re-renders → button shows "Signing In..."<br><br>

                <strong>4. API call to backend</strong><br>
                → await authAPI.login(credentials)<br>
                → POST http://localhost:8080/api/auth/login<br>
                → Request interceptor adds token<br>
                → Waits for backend response...<br><br>

                <strong>5. Backend returns user data</strong><br>
                → toast.success('Login successful!')<br>
                → return response.data.user<br>
                → fulfilled action dispatched<br><br>

                <strong>6. Reducer handles the action</strong><br>
                → state.isLoading = false<br>
                → state.isAuthenticated = true<br>
                → state.user = action.payload<br>
                → Component re-renders<br><br>

                <strong>7. Login component's useEffect runs</strong><br>
                useEffect(() =&gt; {<br>
                  if (isAuthenticated) {<br>
                    navigate('/dashboard');  // Redirect!<br>
                  }<br>
                }, [isAuthenticated]);<br><br>

                <strong>8. Redux-persist saves state to localStorage</strong><br>
                localStorage.setItem('persist:root', JSON.stringify({<br>
                  auth: { user: {...}, isAuthenticated: true }<br>
                }));
            </div>

            <!-- Section 33: Redux Patterns -->
            <h2 id="redux-patterns">33. Redux Use Cases & Patterns</h2>

            <h3>Pattern 1: Loading States</h3>
            <pre><code>function Dashboard() {
  const { isLoading, data, error } = useSelector(
    (state: RootState) =&gt; state.leaves
  );
  
  if (isLoading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} /&gt;;
  if (!data) return null;
  
  return &lt;LeaveList leaves={data} /&gt;;
}</code></pre>

            <h3>Pattern 2: Optimistic Updates</h3>
            <pre><code>export const deleteLeave = createAsyncThunk(
  'leaves/delete',
  async (id: string, { dispatch }) =&gt; {
    // Optimistic: Remove from UI immediately
    dispatch(removeLeaveLocally(id));
    
    try {
      await leaveAPI.delete(id);
    } catch (error) {
      // Rollback on error
      dispatch(restoreLeave(id));
      throw error;
    }
  }
);</code></pre>

            <h3>Pattern 3: Dependent Requests</h3>
            <pre><code>export const loadUserDashboard = createAsyncThunk(
  'dashboard/load',
  async (_, { dispatch }) =&gt; {
    // Load multiple resources
    const user = await dispatch(fetchUser()).unwrap();
    const leaves = await dispatch(fetchLeaves(user.id)).unwrap();
    const team = await dispatch(fetchTeam(user.teamId)).unwrap();
    
    return { user, leaves, team };
  }
);</code></pre>

            <h3>Pattern 4: Polling (Auto-refresh)</h3>
            <pre><code>export const startLeavePolling = createAsyncThunk(
  'leaves/startPolling',
  async (_, { dispatch }) =&gt; {
    const interval = setInterval(() =&gt; {
      dispatch(fetchLeaves());
    }, 30000);  // Every 30 seconds
    
    return interval;
  }
);</code></pre>

            <!-- Section 34: Common Mistakes -->
            <h2 id="redux-mistakes">34. Common Redux Mistakes & Solutions</h2>

            <h3>❌ Mistake 1: Async in Reducers</h3>
            <div class="error">
                <pre><code>// ❌ BAD - Never do async in reducers
reducers: {
  async fetchUser(state) {
    const user = await fetch('/api/user');  // ❌ WRONG!
    state.user = user;
  }
}</code></pre>
            </div>

            <div class="success">
                <pre><code>// ✅ GOOD - Use thunks
const fetchUser = createAsyncThunk('user/fetch', async () =&gt; {
  return await fetch('/api/user');
});</code></pre>
            </div>

            <h3>❌ Mistake 2: Not Handling Loading/Error States</h3>
            <div class="error">
                <pre><code>// ❌ BAD - No loading state
const { data } = useSelector(state =&gt; state.leaves);
return &lt;div&gt;{data.map(...)}&lt;/div&gt;;  // Crashes if data is undefined</code></pre>
            </div>

            <div class="success">
                <pre><code>// ✅ GOOD - Handle all states
const { data, isLoading, error } = useSelector(state =&gt; state.leaves);
if (isLoading) return &lt;Spinner /&gt;;
if (error) return &lt;Error /&gt;;
if (!data) return null;
return &lt;div&gt;{data.map(...)}&lt;/div&gt;;</code></pre>
            </div>

            <h3>❌ Mistake 3: Storing Everything in Redux</h3>
            <div class="error">
                <pre><code>// ❌ BAD - Form inputs in Redux
const { searchTerm } = useSelector(state =&gt; state.search);
dispatch(setSearchTerm(e.target.value));  // Too many re-renders!</code></pre>
            </div>

            <div class="success">
                <pre><code>// ✅ GOOD - Use local state for UI-only data
const [searchTerm, setSearchTerm] = useState('');
// Only dispatch when user submits</code></pre>
            </div>

            <h3>Decision Tree: Redux vs Local State</h3>
            <div class="flow-diagram">
                Do multiple components need this data?<br>
                ├─ YES → Use Redux<br>
                │    Examples: user, auth status, shopping cart<br>
                │<br>
                └─ NO → Use local useState<br>
                     Examples: form inputs, modal open/close, hover state
            </div>

            <!-- Section 35: Redux DevTools -->
            <h2 id="redux-devtools">35. Redux DevTools Usage</h2>

            <h3>What You'll See in DevTools</h3>
            <pre><code>Actions Tab:
├─ @@INIT
├─ persist/REHYDRATE
├─ auth/login/pending
├─ auth/login/fulfilled
└─ auth/logout/fulfilled

State Tab:
auth: {
  user: { id: '1', username: 'john', email: 'j@ex.com' },
  isAuthenticated: true,
  isLoading: false,
  error: null
}

Diff Tab:
+ isAuthenticated: true
+ user: { id: '1', ... }
- isLoading: true</code></pre>

            <h3>Time-Travel Debugging</h3>
            <div class="info">
                <strong>Steps:</strong>
                <ol>
                    <li>Click on "auth/login/pending" action → See state before login started</li>
                    <li>Click on "auth/login/fulfilled" action → See state after login succeeded</li>
                    <li>Click "Jump" button → App goes back to that state in time!</li>
                    <li>See how UI looked at each moment</li>
                </ol>
            </div>

            <h3>Redux Toolkit vs Classic Redux</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Classic Redux</th>
                        <th>Redux Toolkit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Code Amount</td>
                        <td>~100 lines</td>
                        <td>~20 lines (80% less)</td>
                    </tr>
                    <tr>
                        <td>Boilerplate</td>
                        <td>Action types, action creators, switch statements</td>
                        <td>All automatic</td>
                    </tr>
                    <tr>
                        <td>Immutability</td>
                        <td>Manual spreading: <code>{...state}</code></td>
                        <td>Built-in Immer (safe mutations)</td>
                    </tr>
                    <tr>
                        <td>TypeScript</td>
                        <td>Manual type definitions</td>
                        <td>Built-in support</td>
                    </tr>
                    <tr>
                        <td>Async</td>
                        <td>Manual thunk setup</td>
                        <td><code>createAsyncThunk</code></td>
                    </tr>
                </tbody>
            </table>

            <h2>Redux Architecture Summary</h2>
            <div class="flow-diagram">
┌─────────────────────────────────────────────────────────────┐<br>
│                    REDUX ARCHITECTURE                        │<br>
│                                                              │<br>
│  Component                                                   │<br>
│     ↓ dispatch(loginUser({...}))                            │<br>
│  Thunk (async)                                              │<br>
│     ↓ authAPI.login()                                       │<br>
│  API Service                                                │<br>
│     ↓ axios.post()                                          │<br>
│  Backend                                                    │<br>
│     ↓ response                                              │<br>
│  Thunk                                                      │<br>
│     ↓ return user data                                      │<br>
│  Reducer (sync)                                             │<br>
│     ↓ state.user = payload                                  │<br>
│  Redux Store                                                │<br>
│     ↓ state change                                          │<br>
│  Component re-renders                                       │<br>
│     ↓ useSelector                                           │<br>
│  UI updates                                                 │<br>
│                                                              │<br>
│  Redux-Persist saves to localStorage                        │<br>
└─────────────────────────────────────────────────────────────┘
            </div>

            <!-- Next Steps -->
            <h2>🚀 What's Next?</h2>
            <div class="info">
                <ol>
                    <li><strong>Form Validation</strong> - Validate user inputs before submission</li>
                    <li><strong>Error Boundaries</strong> - Catch React errors gracefully</li>
                    <li><strong>Code Splitting</strong> - Lazy load components for performance</li>
                    <li><strong>Testing</strong> - Unit tests for components and Redux</li>
                    <li><strong>Accessibility</strong> - ARIA labels and keyboard navigation</li>
                    <li><strong>Performance Optimization</strong> - useMemo, useCallback, React.memo</li>
                    <li><strong>Deployment</strong> - Build and deploy to production</li>
                </ol>
            </div>

        </div>

        <footer>
            <p>📚 React Learning Notes - Leave Management System Frontend</p>
            <p>Created: October 20, 2025 | Last Updated: October 20, 2025</p>
        </footer>
    </div>
</body>
</html>